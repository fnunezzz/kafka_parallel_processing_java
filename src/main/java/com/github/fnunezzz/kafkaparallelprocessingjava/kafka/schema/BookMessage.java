/**
 * Autogenerated by Avro
 *
 * DO NOT EDIT DIRECTLY
 */
package com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema;

import org.apache.avro.generic.GenericArray;
import org.apache.avro.specific.SpecificData;
import org.apache.avro.util.Utf8;
import org.apache.avro.message.BinaryMessageEncoder;
import org.apache.avro.message.BinaryMessageDecoder;
import org.apache.avro.message.SchemaStore;

@org.apache.avro.specific.AvroGenerated
public class BookMessage extends org.apache.avro.specific.SpecificRecordBase implements org.apache.avro.specific.SpecificRecord {
  private static final long serialVersionUID = -9085022724477073289L;
  public static final org.apache.avro.Schema SCHEMA$ = new org.apache.avro.Schema.Parser().parse("{\"type\":\"record\",\"name\":\"BookMessage\",\"namespace\":\"com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema\",\"fields\":[{\"name\":\"title\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"author\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"authorFirstName\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"authorLastName\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"authorMiddleName\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"categories\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"volume\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"year\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"edition\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"language\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"pages\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"filesize\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"series\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"periodical\",\"type\":[\"boolean\",\"null\"],\"default\":false},{\"name\":\"description\",\"type\":[\"null\",\"string\"],\"default\":null},{\"name\":\"cover\",\"type\":[\"null\",\"string\"],\"default\":null}]}");
  public static org.apache.avro.Schema getClassSchema() { return SCHEMA$; }

  private static SpecificData MODEL$ = new SpecificData();

  private static final BinaryMessageEncoder<BookMessage> ENCODER =
      new BinaryMessageEncoder<BookMessage>(MODEL$, SCHEMA$);

  private static final BinaryMessageDecoder<BookMessage> DECODER =
      new BinaryMessageDecoder<BookMessage>(MODEL$, SCHEMA$);

  /**
   * Return the BinaryMessageEncoder instance used by this class.
   * @return the message encoder used by this class
   */
  public static BinaryMessageEncoder<BookMessage> getEncoder() {
    return ENCODER;
  }

  /**
   * Return the BinaryMessageDecoder instance used by this class.
   * @return the message decoder used by this class
   */
  public static BinaryMessageDecoder<BookMessage> getDecoder() {
    return DECODER;
  }

  /**
   * Create a new BinaryMessageDecoder instance for this class that uses the specified {@link SchemaStore}.
   * @param resolver a {@link SchemaStore} used to find schemas by fingerprint
   * @return a BinaryMessageDecoder instance for this class backed by the given SchemaStore
   */
  public static BinaryMessageDecoder<BookMessage> createDecoder(SchemaStore resolver) {
    return new BinaryMessageDecoder<BookMessage>(MODEL$, SCHEMA$, resolver);
  }

  /**
   * Serializes this BookMessage to a ByteBuffer.
   * @return a buffer holding the serialized data for this instance
   * @throws java.io.IOException if this instance could not be serialized
   */
  public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException {
    return ENCODER.encode(this);
  }

  /**
   * Deserializes a BookMessage from a ByteBuffer.
   * @param b a byte buffer holding serialized data for an instance of this class
   * @return a BookMessage instance decoded from the given buffer
   * @throws java.io.IOException if the given bytes could not be deserialized into an instance of this class
   */
  public static BookMessage fromByteBuffer(
      java.nio.ByteBuffer b) throws java.io.IOException {
    return DECODER.decode(b);
  }

   private java.lang.CharSequence title;
   private java.lang.CharSequence author;
   private java.lang.CharSequence authorFirstName;
   private java.lang.CharSequence authorLastName;
   private java.lang.CharSequence authorMiddleName;
   private java.lang.CharSequence categories;
   private java.lang.CharSequence volume;
   private java.lang.CharSequence year;
   private java.lang.CharSequence edition;
   private java.lang.CharSequence language;
   private java.lang.CharSequence pages;
   private java.lang.CharSequence filesize;
   private java.lang.CharSequence series;
   private java.lang.Boolean periodical;
   private java.lang.CharSequence description;
   private java.lang.CharSequence cover;

  /**
   * Default constructor.  Note that this does not initialize fields
   * to their default values from the schema.  If that is desired then
   * one should use <code>newBuilder()</code>.
   */
  public BookMessage() {}

  /**
   * All-args constructor.
   * @param title The new value for title
   * @param author The new value for author
   * @param authorFirstName The new value for authorFirstName
   * @param authorLastName The new value for authorLastName
   * @param authorMiddleName The new value for authorMiddleName
   * @param categories The new value for categories
   * @param volume The new value for volume
   * @param year The new value for year
   * @param edition The new value for edition
   * @param language The new value for language
   * @param pages The new value for pages
   * @param filesize The new value for filesize
   * @param series The new value for series
   * @param periodical The new value for periodical
   * @param description The new value for description
   * @param cover The new value for cover
   */
  public BookMessage(java.lang.CharSequence title, java.lang.CharSequence author, java.lang.CharSequence authorFirstName, java.lang.CharSequence authorLastName, java.lang.CharSequence authorMiddleName, java.lang.CharSequence categories, java.lang.CharSequence volume, java.lang.CharSequence year, java.lang.CharSequence edition, java.lang.CharSequence language, java.lang.CharSequence pages, java.lang.CharSequence filesize, java.lang.CharSequence series, java.lang.Boolean periodical, java.lang.CharSequence description, java.lang.CharSequence cover) {
    this.title = title;
    this.author = author;
    this.authorFirstName = authorFirstName;
    this.authorLastName = authorLastName;
    this.authorMiddleName = authorMiddleName;
    this.categories = categories;
    this.volume = volume;
    this.year = year;
    this.edition = edition;
    this.language = language;
    this.pages = pages;
    this.filesize = filesize;
    this.series = series;
    this.periodical = periodical;
    this.description = description;
    this.cover = cover;
  }

  public org.apache.avro.specific.SpecificData getSpecificData() { return MODEL$; }
  public org.apache.avro.Schema getSchema() { return SCHEMA$; }
  // Used by DatumWriter.  Applications should not call.
  public java.lang.Object get(int field$) {
    switch (field$) {
    case 0: return title;
    case 1: return author;
    case 2: return authorFirstName;
    case 3: return authorLastName;
    case 4: return authorMiddleName;
    case 5: return categories;
    case 6: return volume;
    case 7: return year;
    case 8: return edition;
    case 9: return language;
    case 10: return pages;
    case 11: return filesize;
    case 12: return series;
    case 13: return periodical;
    case 14: return description;
    case 15: return cover;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  // Used by DatumReader.  Applications should not call.
  @SuppressWarnings(value="unchecked")
  public void put(int field$, java.lang.Object value$) {
    switch (field$) {
    case 0: title = (java.lang.CharSequence)value$; break;
    case 1: author = (java.lang.CharSequence)value$; break;
    case 2: authorFirstName = (java.lang.CharSequence)value$; break;
    case 3: authorLastName = (java.lang.CharSequence)value$; break;
    case 4: authorMiddleName = (java.lang.CharSequence)value$; break;
    case 5: categories = (java.lang.CharSequence)value$; break;
    case 6: volume = (java.lang.CharSequence)value$; break;
    case 7: year = (java.lang.CharSequence)value$; break;
    case 8: edition = (java.lang.CharSequence)value$; break;
    case 9: language = (java.lang.CharSequence)value$; break;
    case 10: pages = (java.lang.CharSequence)value$; break;
    case 11: filesize = (java.lang.CharSequence)value$; break;
    case 12: series = (java.lang.CharSequence)value$; break;
    case 13: periodical = (java.lang.Boolean)value$; break;
    case 14: description = (java.lang.CharSequence)value$; break;
    case 15: cover = (java.lang.CharSequence)value$; break;
    default: throw new IndexOutOfBoundsException("Invalid index: " + field$);
    }
  }

  /**
   * Gets the value of the 'title' field.
   * @return The value of the 'title' field.
   */
  public java.lang.CharSequence getTitle() {
    return title;
  }


  /**
   * Sets the value of the 'title' field.
   * @param value the value to set.
   */
  public void setTitle(java.lang.CharSequence value) {
    this.title = value;
  }

  /**
   * Gets the value of the 'author' field.
   * @return The value of the 'author' field.
   */
  public java.lang.CharSequence getAuthor() {
    return author;
  }


  /**
   * Sets the value of the 'author' field.
   * @param value the value to set.
   */
  public void setAuthor(java.lang.CharSequence value) {
    this.author = value;
  }

  /**
   * Gets the value of the 'authorFirstName' field.
   * @return The value of the 'authorFirstName' field.
   */
  public java.lang.CharSequence getAuthorFirstName() {
    return authorFirstName;
  }


  /**
   * Sets the value of the 'authorFirstName' field.
   * @param value the value to set.
   */
  public void setAuthorFirstName(java.lang.CharSequence value) {
    this.authorFirstName = value;
  }

  /**
   * Gets the value of the 'authorLastName' field.
   * @return The value of the 'authorLastName' field.
   */
  public java.lang.CharSequence getAuthorLastName() {
    return authorLastName;
  }


  /**
   * Sets the value of the 'authorLastName' field.
   * @param value the value to set.
   */
  public void setAuthorLastName(java.lang.CharSequence value) {
    this.authorLastName = value;
  }

  /**
   * Gets the value of the 'authorMiddleName' field.
   * @return The value of the 'authorMiddleName' field.
   */
  public java.lang.CharSequence getAuthorMiddleName() {
    return authorMiddleName;
  }


  /**
   * Sets the value of the 'authorMiddleName' field.
   * @param value the value to set.
   */
  public void setAuthorMiddleName(java.lang.CharSequence value) {
    this.authorMiddleName = value;
  }

  /**
   * Gets the value of the 'categories' field.
   * @return The value of the 'categories' field.
   */
  public java.lang.CharSequence getCategories() {
    return categories;
  }


  /**
   * Sets the value of the 'categories' field.
   * @param value the value to set.
   */
  public void setCategories(java.lang.CharSequence value) {
    this.categories = value;
  }

  /**
   * Gets the value of the 'volume' field.
   * @return The value of the 'volume' field.
   */
  public java.lang.CharSequence getVolume() {
    return volume;
  }


  /**
   * Sets the value of the 'volume' field.
   * @param value the value to set.
   */
  public void setVolume(java.lang.CharSequence value) {
    this.volume = value;
  }

  /**
   * Gets the value of the 'year' field.
   * @return The value of the 'year' field.
   */
  public java.lang.CharSequence getYear() {
    return year;
  }


  /**
   * Sets the value of the 'year' field.
   * @param value the value to set.
   */
  public void setYear(java.lang.CharSequence value) {
    this.year = value;
  }

  /**
   * Gets the value of the 'edition' field.
   * @return The value of the 'edition' field.
   */
  public java.lang.CharSequence getEdition() {
    return edition;
  }


  /**
   * Sets the value of the 'edition' field.
   * @param value the value to set.
   */
  public void setEdition(java.lang.CharSequence value) {
    this.edition = value;
  }

  /**
   * Gets the value of the 'language' field.
   * @return The value of the 'language' field.
   */
  public java.lang.CharSequence getLanguage() {
    return language;
  }


  /**
   * Sets the value of the 'language' field.
   * @param value the value to set.
   */
  public void setLanguage(java.lang.CharSequence value) {
    this.language = value;
  }

  /**
   * Gets the value of the 'pages' field.
   * @return The value of the 'pages' field.
   */
  public java.lang.CharSequence getPages() {
    return pages;
  }


  /**
   * Sets the value of the 'pages' field.
   * @param value the value to set.
   */
  public void setPages(java.lang.CharSequence value) {
    this.pages = value;
  }

  /**
   * Gets the value of the 'filesize' field.
   * @return The value of the 'filesize' field.
   */
  public java.lang.CharSequence getFilesize() {
    return filesize;
  }


  /**
   * Sets the value of the 'filesize' field.
   * @param value the value to set.
   */
  public void setFilesize(java.lang.CharSequence value) {
    this.filesize = value;
  }

  /**
   * Gets the value of the 'series' field.
   * @return The value of the 'series' field.
   */
  public java.lang.CharSequence getSeries() {
    return series;
  }


  /**
   * Sets the value of the 'series' field.
   * @param value the value to set.
   */
  public void setSeries(java.lang.CharSequence value) {
    this.series = value;
  }

  /**
   * Gets the value of the 'periodical' field.
   * @return The value of the 'periodical' field.
   */
  public java.lang.Boolean getPeriodical() {
    return periodical;
  }


  /**
   * Sets the value of the 'periodical' field.
   * @param value the value to set.
   */
  public void setPeriodical(java.lang.Boolean value) {
    this.periodical = value;
  }

  /**
   * Gets the value of the 'description' field.
   * @return The value of the 'description' field.
   */
  public java.lang.CharSequence getDescription() {
    return description;
  }


  /**
   * Sets the value of the 'description' field.
   * @param value the value to set.
   */
  public void setDescription(java.lang.CharSequence value) {
    this.description = value;
  }

  /**
   * Gets the value of the 'cover' field.
   * @return The value of the 'cover' field.
   */
  public java.lang.CharSequence getCover() {
    return cover;
  }


  /**
   * Sets the value of the 'cover' field.
   * @param value the value to set.
   */
  public void setCover(java.lang.CharSequence value) {
    this.cover = value;
  }

  /**
   * Creates a new BookMessage RecordBuilder.
   * @return A new BookMessage RecordBuilder
   */
  public static com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder newBuilder() {
    return new com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder();
  }

  /**
   * Creates a new BookMessage RecordBuilder by copying an existing Builder.
   * @param other The existing builder to copy.
   * @return A new BookMessage RecordBuilder
   */
  public static com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder newBuilder(com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder other) {
    if (other == null) {
      return new com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder();
    } else {
      return new com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder(other);
    }
  }

  /**
   * Creates a new BookMessage RecordBuilder by copying an existing BookMessage instance.
   * @param other The existing instance to copy.
   * @return A new BookMessage RecordBuilder
   */
  public static com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder newBuilder(com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage other) {
    if (other == null) {
      return new com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder();
    } else {
      return new com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder(other);
    }
  }

  /**
   * RecordBuilder for BookMessage instances.
   */
  @org.apache.avro.specific.AvroGenerated
  public static class Builder extends org.apache.avro.specific.SpecificRecordBuilderBase<BookMessage>
    implements org.apache.avro.data.RecordBuilder<BookMessage> {

    private java.lang.CharSequence title;
    private java.lang.CharSequence author;
    private java.lang.CharSequence authorFirstName;
    private java.lang.CharSequence authorLastName;
    private java.lang.CharSequence authorMiddleName;
    private java.lang.CharSequence categories;
    private java.lang.CharSequence volume;
    private java.lang.CharSequence year;
    private java.lang.CharSequence edition;
    private java.lang.CharSequence language;
    private java.lang.CharSequence pages;
    private java.lang.CharSequence filesize;
    private java.lang.CharSequence series;
    private java.lang.Boolean periodical;
    private java.lang.CharSequence description;
    private java.lang.CharSequence cover;

    /** Creates a new Builder */
    private Builder() {
      super(SCHEMA$);
    }

    /**
     * Creates a Builder by copying an existing Builder.
     * @param other The existing Builder to copy.
     */
    private Builder(com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder other) {
      super(other);
      if (isValidValue(fields()[0], other.title)) {
        this.title = data().deepCopy(fields()[0].schema(), other.title);
        fieldSetFlags()[0] = other.fieldSetFlags()[0];
      }
      if (isValidValue(fields()[1], other.author)) {
        this.author = data().deepCopy(fields()[1].schema(), other.author);
        fieldSetFlags()[1] = other.fieldSetFlags()[1];
      }
      if (isValidValue(fields()[2], other.authorFirstName)) {
        this.authorFirstName = data().deepCopy(fields()[2].schema(), other.authorFirstName);
        fieldSetFlags()[2] = other.fieldSetFlags()[2];
      }
      if (isValidValue(fields()[3], other.authorLastName)) {
        this.authorLastName = data().deepCopy(fields()[3].schema(), other.authorLastName);
        fieldSetFlags()[3] = other.fieldSetFlags()[3];
      }
      if (isValidValue(fields()[4], other.authorMiddleName)) {
        this.authorMiddleName = data().deepCopy(fields()[4].schema(), other.authorMiddleName);
        fieldSetFlags()[4] = other.fieldSetFlags()[4];
      }
      if (isValidValue(fields()[5], other.categories)) {
        this.categories = data().deepCopy(fields()[5].schema(), other.categories);
        fieldSetFlags()[5] = other.fieldSetFlags()[5];
      }
      if (isValidValue(fields()[6], other.volume)) {
        this.volume = data().deepCopy(fields()[6].schema(), other.volume);
        fieldSetFlags()[6] = other.fieldSetFlags()[6];
      }
      if (isValidValue(fields()[7], other.year)) {
        this.year = data().deepCopy(fields()[7].schema(), other.year);
        fieldSetFlags()[7] = other.fieldSetFlags()[7];
      }
      if (isValidValue(fields()[8], other.edition)) {
        this.edition = data().deepCopy(fields()[8].schema(), other.edition);
        fieldSetFlags()[8] = other.fieldSetFlags()[8];
      }
      if (isValidValue(fields()[9], other.language)) {
        this.language = data().deepCopy(fields()[9].schema(), other.language);
        fieldSetFlags()[9] = other.fieldSetFlags()[9];
      }
      if (isValidValue(fields()[10], other.pages)) {
        this.pages = data().deepCopy(fields()[10].schema(), other.pages);
        fieldSetFlags()[10] = other.fieldSetFlags()[10];
      }
      if (isValidValue(fields()[11], other.filesize)) {
        this.filesize = data().deepCopy(fields()[11].schema(), other.filesize);
        fieldSetFlags()[11] = other.fieldSetFlags()[11];
      }
      if (isValidValue(fields()[12], other.series)) {
        this.series = data().deepCopy(fields()[12].schema(), other.series);
        fieldSetFlags()[12] = other.fieldSetFlags()[12];
      }
      if (isValidValue(fields()[13], other.periodical)) {
        this.periodical = data().deepCopy(fields()[13].schema(), other.periodical);
        fieldSetFlags()[13] = other.fieldSetFlags()[13];
      }
      if (isValidValue(fields()[14], other.description)) {
        this.description = data().deepCopy(fields()[14].schema(), other.description);
        fieldSetFlags()[14] = other.fieldSetFlags()[14];
      }
      if (isValidValue(fields()[15], other.cover)) {
        this.cover = data().deepCopy(fields()[15].schema(), other.cover);
        fieldSetFlags()[15] = other.fieldSetFlags()[15];
      }
    }

    /**
     * Creates a Builder by copying an existing BookMessage instance
     * @param other The existing instance to copy.
     */
    private Builder(com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage other) {
      super(SCHEMA$);
      if (isValidValue(fields()[0], other.title)) {
        this.title = data().deepCopy(fields()[0].schema(), other.title);
        fieldSetFlags()[0] = true;
      }
      if (isValidValue(fields()[1], other.author)) {
        this.author = data().deepCopy(fields()[1].schema(), other.author);
        fieldSetFlags()[1] = true;
      }
      if (isValidValue(fields()[2], other.authorFirstName)) {
        this.authorFirstName = data().deepCopy(fields()[2].schema(), other.authorFirstName);
        fieldSetFlags()[2] = true;
      }
      if (isValidValue(fields()[3], other.authorLastName)) {
        this.authorLastName = data().deepCopy(fields()[3].schema(), other.authorLastName);
        fieldSetFlags()[3] = true;
      }
      if (isValidValue(fields()[4], other.authorMiddleName)) {
        this.authorMiddleName = data().deepCopy(fields()[4].schema(), other.authorMiddleName);
        fieldSetFlags()[4] = true;
      }
      if (isValidValue(fields()[5], other.categories)) {
        this.categories = data().deepCopy(fields()[5].schema(), other.categories);
        fieldSetFlags()[5] = true;
      }
      if (isValidValue(fields()[6], other.volume)) {
        this.volume = data().deepCopy(fields()[6].schema(), other.volume);
        fieldSetFlags()[6] = true;
      }
      if (isValidValue(fields()[7], other.year)) {
        this.year = data().deepCopy(fields()[7].schema(), other.year);
        fieldSetFlags()[7] = true;
      }
      if (isValidValue(fields()[8], other.edition)) {
        this.edition = data().deepCopy(fields()[8].schema(), other.edition);
        fieldSetFlags()[8] = true;
      }
      if (isValidValue(fields()[9], other.language)) {
        this.language = data().deepCopy(fields()[9].schema(), other.language);
        fieldSetFlags()[9] = true;
      }
      if (isValidValue(fields()[10], other.pages)) {
        this.pages = data().deepCopy(fields()[10].schema(), other.pages);
        fieldSetFlags()[10] = true;
      }
      if (isValidValue(fields()[11], other.filesize)) {
        this.filesize = data().deepCopy(fields()[11].schema(), other.filesize);
        fieldSetFlags()[11] = true;
      }
      if (isValidValue(fields()[12], other.series)) {
        this.series = data().deepCopy(fields()[12].schema(), other.series);
        fieldSetFlags()[12] = true;
      }
      if (isValidValue(fields()[13], other.periodical)) {
        this.periodical = data().deepCopy(fields()[13].schema(), other.periodical);
        fieldSetFlags()[13] = true;
      }
      if (isValidValue(fields()[14], other.description)) {
        this.description = data().deepCopy(fields()[14].schema(), other.description);
        fieldSetFlags()[14] = true;
      }
      if (isValidValue(fields()[15], other.cover)) {
        this.cover = data().deepCopy(fields()[15].schema(), other.cover);
        fieldSetFlags()[15] = true;
      }
    }

    /**
      * Gets the value of the 'title' field.
      * @return The value.
      */
    public java.lang.CharSequence getTitle() {
      return title;
    }


    /**
      * Sets the value of the 'title' field.
      * @param value The value of 'title'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setTitle(java.lang.CharSequence value) {
      validate(fields()[0], value);
      this.title = value;
      fieldSetFlags()[0] = true;
      return this;
    }

    /**
      * Checks whether the 'title' field has been set.
      * @return True if the 'title' field has been set, false otherwise.
      */
    public boolean hasTitle() {
      return fieldSetFlags()[0];
    }


    /**
      * Clears the value of the 'title' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearTitle() {
      title = null;
      fieldSetFlags()[0] = false;
      return this;
    }

    /**
      * Gets the value of the 'author' field.
      * @return The value.
      */
    public java.lang.CharSequence getAuthor() {
      return author;
    }


    /**
      * Sets the value of the 'author' field.
      * @param value The value of 'author'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setAuthor(java.lang.CharSequence value) {
      validate(fields()[1], value);
      this.author = value;
      fieldSetFlags()[1] = true;
      return this;
    }

    /**
      * Checks whether the 'author' field has been set.
      * @return True if the 'author' field has been set, false otherwise.
      */
    public boolean hasAuthor() {
      return fieldSetFlags()[1];
    }


    /**
      * Clears the value of the 'author' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearAuthor() {
      author = null;
      fieldSetFlags()[1] = false;
      return this;
    }

    /**
      * Gets the value of the 'authorFirstName' field.
      * @return The value.
      */
    public java.lang.CharSequence getAuthorFirstName() {
      return authorFirstName;
    }


    /**
      * Sets the value of the 'authorFirstName' field.
      * @param value The value of 'authorFirstName'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setAuthorFirstName(java.lang.CharSequence value) {
      validate(fields()[2], value);
      this.authorFirstName = value;
      fieldSetFlags()[2] = true;
      return this;
    }

    /**
      * Checks whether the 'authorFirstName' field has been set.
      * @return True if the 'authorFirstName' field has been set, false otherwise.
      */
    public boolean hasAuthorFirstName() {
      return fieldSetFlags()[2];
    }


    /**
      * Clears the value of the 'authorFirstName' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearAuthorFirstName() {
      authorFirstName = null;
      fieldSetFlags()[2] = false;
      return this;
    }

    /**
      * Gets the value of the 'authorLastName' field.
      * @return The value.
      */
    public java.lang.CharSequence getAuthorLastName() {
      return authorLastName;
    }


    /**
      * Sets the value of the 'authorLastName' field.
      * @param value The value of 'authorLastName'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setAuthorLastName(java.lang.CharSequence value) {
      validate(fields()[3], value);
      this.authorLastName = value;
      fieldSetFlags()[3] = true;
      return this;
    }

    /**
      * Checks whether the 'authorLastName' field has been set.
      * @return True if the 'authorLastName' field has been set, false otherwise.
      */
    public boolean hasAuthorLastName() {
      return fieldSetFlags()[3];
    }


    /**
      * Clears the value of the 'authorLastName' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearAuthorLastName() {
      authorLastName = null;
      fieldSetFlags()[3] = false;
      return this;
    }

    /**
      * Gets the value of the 'authorMiddleName' field.
      * @return The value.
      */
    public java.lang.CharSequence getAuthorMiddleName() {
      return authorMiddleName;
    }


    /**
      * Sets the value of the 'authorMiddleName' field.
      * @param value The value of 'authorMiddleName'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setAuthorMiddleName(java.lang.CharSequence value) {
      validate(fields()[4], value);
      this.authorMiddleName = value;
      fieldSetFlags()[4] = true;
      return this;
    }

    /**
      * Checks whether the 'authorMiddleName' field has been set.
      * @return True if the 'authorMiddleName' field has been set, false otherwise.
      */
    public boolean hasAuthorMiddleName() {
      return fieldSetFlags()[4];
    }


    /**
      * Clears the value of the 'authorMiddleName' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearAuthorMiddleName() {
      authorMiddleName = null;
      fieldSetFlags()[4] = false;
      return this;
    }

    /**
      * Gets the value of the 'categories' field.
      * @return The value.
      */
    public java.lang.CharSequence getCategories() {
      return categories;
    }


    /**
      * Sets the value of the 'categories' field.
      * @param value The value of 'categories'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setCategories(java.lang.CharSequence value) {
      validate(fields()[5], value);
      this.categories = value;
      fieldSetFlags()[5] = true;
      return this;
    }

    /**
      * Checks whether the 'categories' field has been set.
      * @return True if the 'categories' field has been set, false otherwise.
      */
    public boolean hasCategories() {
      return fieldSetFlags()[5];
    }


    /**
      * Clears the value of the 'categories' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearCategories() {
      categories = null;
      fieldSetFlags()[5] = false;
      return this;
    }

    /**
      * Gets the value of the 'volume' field.
      * @return The value.
      */
    public java.lang.CharSequence getVolume() {
      return volume;
    }


    /**
      * Sets the value of the 'volume' field.
      * @param value The value of 'volume'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setVolume(java.lang.CharSequence value) {
      validate(fields()[6], value);
      this.volume = value;
      fieldSetFlags()[6] = true;
      return this;
    }

    /**
      * Checks whether the 'volume' field has been set.
      * @return True if the 'volume' field has been set, false otherwise.
      */
    public boolean hasVolume() {
      return fieldSetFlags()[6];
    }


    /**
      * Clears the value of the 'volume' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearVolume() {
      volume = null;
      fieldSetFlags()[6] = false;
      return this;
    }

    /**
      * Gets the value of the 'year' field.
      * @return The value.
      */
    public java.lang.CharSequence getYear() {
      return year;
    }


    /**
      * Sets the value of the 'year' field.
      * @param value The value of 'year'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setYear(java.lang.CharSequence value) {
      validate(fields()[7], value);
      this.year = value;
      fieldSetFlags()[7] = true;
      return this;
    }

    /**
      * Checks whether the 'year' field has been set.
      * @return True if the 'year' field has been set, false otherwise.
      */
    public boolean hasYear() {
      return fieldSetFlags()[7];
    }


    /**
      * Clears the value of the 'year' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearYear() {
      year = null;
      fieldSetFlags()[7] = false;
      return this;
    }

    /**
      * Gets the value of the 'edition' field.
      * @return The value.
      */
    public java.lang.CharSequence getEdition() {
      return edition;
    }


    /**
      * Sets the value of the 'edition' field.
      * @param value The value of 'edition'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setEdition(java.lang.CharSequence value) {
      validate(fields()[8], value);
      this.edition = value;
      fieldSetFlags()[8] = true;
      return this;
    }

    /**
      * Checks whether the 'edition' field has been set.
      * @return True if the 'edition' field has been set, false otherwise.
      */
    public boolean hasEdition() {
      return fieldSetFlags()[8];
    }


    /**
      * Clears the value of the 'edition' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearEdition() {
      edition = null;
      fieldSetFlags()[8] = false;
      return this;
    }

    /**
      * Gets the value of the 'language' field.
      * @return The value.
      */
    public java.lang.CharSequence getLanguage() {
      return language;
    }


    /**
      * Sets the value of the 'language' field.
      * @param value The value of 'language'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setLanguage(java.lang.CharSequence value) {
      validate(fields()[9], value);
      this.language = value;
      fieldSetFlags()[9] = true;
      return this;
    }

    /**
      * Checks whether the 'language' field has been set.
      * @return True if the 'language' field has been set, false otherwise.
      */
    public boolean hasLanguage() {
      return fieldSetFlags()[9];
    }


    /**
      * Clears the value of the 'language' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearLanguage() {
      language = null;
      fieldSetFlags()[9] = false;
      return this;
    }

    /**
      * Gets the value of the 'pages' field.
      * @return The value.
      */
    public java.lang.CharSequence getPages() {
      return pages;
    }


    /**
      * Sets the value of the 'pages' field.
      * @param value The value of 'pages'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setPages(java.lang.CharSequence value) {
      validate(fields()[10], value);
      this.pages = value;
      fieldSetFlags()[10] = true;
      return this;
    }

    /**
      * Checks whether the 'pages' field has been set.
      * @return True if the 'pages' field has been set, false otherwise.
      */
    public boolean hasPages() {
      return fieldSetFlags()[10];
    }


    /**
      * Clears the value of the 'pages' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearPages() {
      pages = null;
      fieldSetFlags()[10] = false;
      return this;
    }

    /**
      * Gets the value of the 'filesize' field.
      * @return The value.
      */
    public java.lang.CharSequence getFilesize() {
      return filesize;
    }


    /**
      * Sets the value of the 'filesize' field.
      * @param value The value of 'filesize'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setFilesize(java.lang.CharSequence value) {
      validate(fields()[11], value);
      this.filesize = value;
      fieldSetFlags()[11] = true;
      return this;
    }

    /**
      * Checks whether the 'filesize' field has been set.
      * @return True if the 'filesize' field has been set, false otherwise.
      */
    public boolean hasFilesize() {
      return fieldSetFlags()[11];
    }


    /**
      * Clears the value of the 'filesize' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearFilesize() {
      filesize = null;
      fieldSetFlags()[11] = false;
      return this;
    }

    /**
      * Gets the value of the 'series' field.
      * @return The value.
      */
    public java.lang.CharSequence getSeries() {
      return series;
    }


    /**
      * Sets the value of the 'series' field.
      * @param value The value of 'series'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setSeries(java.lang.CharSequence value) {
      validate(fields()[12], value);
      this.series = value;
      fieldSetFlags()[12] = true;
      return this;
    }

    /**
      * Checks whether the 'series' field has been set.
      * @return True if the 'series' field has been set, false otherwise.
      */
    public boolean hasSeries() {
      return fieldSetFlags()[12];
    }


    /**
      * Clears the value of the 'series' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearSeries() {
      series = null;
      fieldSetFlags()[12] = false;
      return this;
    }

    /**
      * Gets the value of the 'periodical' field.
      * @return The value.
      */
    public java.lang.Boolean getPeriodical() {
      return periodical;
    }


    /**
      * Sets the value of the 'periodical' field.
      * @param value The value of 'periodical'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setPeriodical(java.lang.Boolean value) {
      validate(fields()[13], value);
      this.periodical = value;
      fieldSetFlags()[13] = true;
      return this;
    }

    /**
      * Checks whether the 'periodical' field has been set.
      * @return True if the 'periodical' field has been set, false otherwise.
      */
    public boolean hasPeriodical() {
      return fieldSetFlags()[13];
    }


    /**
      * Clears the value of the 'periodical' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearPeriodical() {
      periodical = null;
      fieldSetFlags()[13] = false;
      return this;
    }

    /**
      * Gets the value of the 'description' field.
      * @return The value.
      */
    public java.lang.CharSequence getDescription() {
      return description;
    }


    /**
      * Sets the value of the 'description' field.
      * @param value The value of 'description'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setDescription(java.lang.CharSequence value) {
      validate(fields()[14], value);
      this.description = value;
      fieldSetFlags()[14] = true;
      return this;
    }

    /**
      * Checks whether the 'description' field has been set.
      * @return True if the 'description' field has been set, false otherwise.
      */
    public boolean hasDescription() {
      return fieldSetFlags()[14];
    }


    /**
      * Clears the value of the 'description' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearDescription() {
      description = null;
      fieldSetFlags()[14] = false;
      return this;
    }

    /**
      * Gets the value of the 'cover' field.
      * @return The value.
      */
    public java.lang.CharSequence getCover() {
      return cover;
    }


    /**
      * Sets the value of the 'cover' field.
      * @param value The value of 'cover'.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder setCover(java.lang.CharSequence value) {
      validate(fields()[15], value);
      this.cover = value;
      fieldSetFlags()[15] = true;
      return this;
    }

    /**
      * Checks whether the 'cover' field has been set.
      * @return True if the 'cover' field has been set, false otherwise.
      */
    public boolean hasCover() {
      return fieldSetFlags()[15];
    }


    /**
      * Clears the value of the 'cover' field.
      * @return This builder.
      */
    public com.github.fnunezzz.kafkaparallelprocessingjava.kafka.schema.BookMessage.Builder clearCover() {
      cover = null;
      fieldSetFlags()[15] = false;
      return this;
    }

    @Override
    @SuppressWarnings("unchecked")
    public BookMessage build() {
      try {
        BookMessage record = new BookMessage();
        record.title = fieldSetFlags()[0] ? this.title : (java.lang.CharSequence) defaultValue(fields()[0]);
        record.author = fieldSetFlags()[1] ? this.author : (java.lang.CharSequence) defaultValue(fields()[1]);
        record.authorFirstName = fieldSetFlags()[2] ? this.authorFirstName : (java.lang.CharSequence) defaultValue(fields()[2]);
        record.authorLastName = fieldSetFlags()[3] ? this.authorLastName : (java.lang.CharSequence) defaultValue(fields()[3]);
        record.authorMiddleName = fieldSetFlags()[4] ? this.authorMiddleName : (java.lang.CharSequence) defaultValue(fields()[4]);
        record.categories = fieldSetFlags()[5] ? this.categories : (java.lang.CharSequence) defaultValue(fields()[5]);
        record.volume = fieldSetFlags()[6] ? this.volume : (java.lang.CharSequence) defaultValue(fields()[6]);
        record.year = fieldSetFlags()[7] ? this.year : (java.lang.CharSequence) defaultValue(fields()[7]);
        record.edition = fieldSetFlags()[8] ? this.edition : (java.lang.CharSequence) defaultValue(fields()[8]);
        record.language = fieldSetFlags()[9] ? this.language : (java.lang.CharSequence) defaultValue(fields()[9]);
        record.pages = fieldSetFlags()[10] ? this.pages : (java.lang.CharSequence) defaultValue(fields()[10]);
        record.filesize = fieldSetFlags()[11] ? this.filesize : (java.lang.CharSequence) defaultValue(fields()[11]);
        record.series = fieldSetFlags()[12] ? this.series : (java.lang.CharSequence) defaultValue(fields()[12]);
        record.periodical = fieldSetFlags()[13] ? this.periodical : (java.lang.Boolean) defaultValue(fields()[13]);
        record.description = fieldSetFlags()[14] ? this.description : (java.lang.CharSequence) defaultValue(fields()[14]);
        record.cover = fieldSetFlags()[15] ? this.cover : (java.lang.CharSequence) defaultValue(fields()[15]);
        return record;
      } catch (org.apache.avro.AvroMissingFieldException e) {
        throw e;
      } catch (java.lang.Exception e) {
        throw new org.apache.avro.AvroRuntimeException(e);
      }
    }
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumWriter<BookMessage>
    WRITER$ = (org.apache.avro.io.DatumWriter<BookMessage>)MODEL$.createDatumWriter(SCHEMA$);

  @Override public void writeExternal(java.io.ObjectOutput out)
    throws java.io.IOException {
    WRITER$.write(this, SpecificData.getEncoder(out));
  }

  @SuppressWarnings("unchecked")
  private static final org.apache.avro.io.DatumReader<BookMessage>
    READER$ = (org.apache.avro.io.DatumReader<BookMessage>)MODEL$.createDatumReader(SCHEMA$);

  @Override public void readExternal(java.io.ObjectInput in)
    throws java.io.IOException {
    READER$.read(this, SpecificData.getDecoder(in));
  }

  @Override protected boolean hasCustomCoders() { return true; }

  @Override public void customEncode(org.apache.avro.io.Encoder out)
    throws java.io.IOException
  {
    if (this.title == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.title);
    }

    if (this.author == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.author);
    }

    if (this.authorFirstName == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.authorFirstName);
    }

    if (this.authorLastName == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.authorLastName);
    }

    if (this.authorMiddleName == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.authorMiddleName);
    }

    if (this.categories == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.categories);
    }

    if (this.volume == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.volume);
    }

    if (this.year == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.year);
    }

    if (this.edition == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.edition);
    }

    if (this.language == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.language);
    }

    if (this.pages == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.pages);
    }

    if (this.filesize == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.filesize);
    }

    if (this.series == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.series);
    }

    if (this.periodical == null) {
      out.writeIndex(1);
      out.writeNull();
    } else {
      out.writeIndex(0);
      out.writeBoolean(this.periodical);
    }

    if (this.description == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.description);
    }

    if (this.cover == null) {
      out.writeIndex(0);
      out.writeNull();
    } else {
      out.writeIndex(1);
      out.writeString(this.cover);
    }

  }

  @Override public void customDecode(org.apache.avro.io.ResolvingDecoder in)
    throws java.io.IOException
  {
    org.apache.avro.Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();
    if (fieldOrder == null) {
      if (in.readIndex() != 1) {
        in.readNull();
        this.title = null;
      } else {
        this.title = in.readString(this.title instanceof Utf8 ? (Utf8)this.title : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.author = null;
      } else {
        this.author = in.readString(this.author instanceof Utf8 ? (Utf8)this.author : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.authorFirstName = null;
      } else {
        this.authorFirstName = in.readString(this.authorFirstName instanceof Utf8 ? (Utf8)this.authorFirstName : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.authorLastName = null;
      } else {
        this.authorLastName = in.readString(this.authorLastName instanceof Utf8 ? (Utf8)this.authorLastName : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.authorMiddleName = null;
      } else {
        this.authorMiddleName = in.readString(this.authorMiddleName instanceof Utf8 ? (Utf8)this.authorMiddleName : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.categories = null;
      } else {
        this.categories = in.readString(this.categories instanceof Utf8 ? (Utf8)this.categories : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.volume = null;
      } else {
        this.volume = in.readString(this.volume instanceof Utf8 ? (Utf8)this.volume : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.year = null;
      } else {
        this.year = in.readString(this.year instanceof Utf8 ? (Utf8)this.year : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.edition = null;
      } else {
        this.edition = in.readString(this.edition instanceof Utf8 ? (Utf8)this.edition : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.language = null;
      } else {
        this.language = in.readString(this.language instanceof Utf8 ? (Utf8)this.language : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.pages = null;
      } else {
        this.pages = in.readString(this.pages instanceof Utf8 ? (Utf8)this.pages : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.filesize = null;
      } else {
        this.filesize = in.readString(this.filesize instanceof Utf8 ? (Utf8)this.filesize : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.series = null;
      } else {
        this.series = in.readString(this.series instanceof Utf8 ? (Utf8)this.series : null);
      }

      if (in.readIndex() != 0) {
        in.readNull();
        this.periodical = null;
      } else {
        this.periodical = in.readBoolean();
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.description = null;
      } else {
        this.description = in.readString(this.description instanceof Utf8 ? (Utf8)this.description : null);
      }

      if (in.readIndex() != 1) {
        in.readNull();
        this.cover = null;
      } else {
        this.cover = in.readString(this.cover instanceof Utf8 ? (Utf8)this.cover : null);
      }

    } else {
      for (int i = 0; i < 16; i++) {
        switch (fieldOrder[i].pos()) {
        case 0:
          if (in.readIndex() != 1) {
            in.readNull();
            this.title = null;
          } else {
            this.title = in.readString(this.title instanceof Utf8 ? (Utf8)this.title : null);
          }
          break;

        case 1:
          if (in.readIndex() != 1) {
            in.readNull();
            this.author = null;
          } else {
            this.author = in.readString(this.author instanceof Utf8 ? (Utf8)this.author : null);
          }
          break;

        case 2:
          if (in.readIndex() != 1) {
            in.readNull();
            this.authorFirstName = null;
          } else {
            this.authorFirstName = in.readString(this.authorFirstName instanceof Utf8 ? (Utf8)this.authorFirstName : null);
          }
          break;

        case 3:
          if (in.readIndex() != 1) {
            in.readNull();
            this.authorLastName = null;
          } else {
            this.authorLastName = in.readString(this.authorLastName instanceof Utf8 ? (Utf8)this.authorLastName : null);
          }
          break;

        case 4:
          if (in.readIndex() != 1) {
            in.readNull();
            this.authorMiddleName = null;
          } else {
            this.authorMiddleName = in.readString(this.authorMiddleName instanceof Utf8 ? (Utf8)this.authorMiddleName : null);
          }
          break;

        case 5:
          if (in.readIndex() != 1) {
            in.readNull();
            this.categories = null;
          } else {
            this.categories = in.readString(this.categories instanceof Utf8 ? (Utf8)this.categories : null);
          }
          break;

        case 6:
          if (in.readIndex() != 1) {
            in.readNull();
            this.volume = null;
          } else {
            this.volume = in.readString(this.volume instanceof Utf8 ? (Utf8)this.volume : null);
          }
          break;

        case 7:
          if (in.readIndex() != 1) {
            in.readNull();
            this.year = null;
          } else {
            this.year = in.readString(this.year instanceof Utf8 ? (Utf8)this.year : null);
          }
          break;

        case 8:
          if (in.readIndex() != 1) {
            in.readNull();
            this.edition = null;
          } else {
            this.edition = in.readString(this.edition instanceof Utf8 ? (Utf8)this.edition : null);
          }
          break;

        case 9:
          if (in.readIndex() != 1) {
            in.readNull();
            this.language = null;
          } else {
            this.language = in.readString(this.language instanceof Utf8 ? (Utf8)this.language : null);
          }
          break;

        case 10:
          if (in.readIndex() != 1) {
            in.readNull();
            this.pages = null;
          } else {
            this.pages = in.readString(this.pages instanceof Utf8 ? (Utf8)this.pages : null);
          }
          break;

        case 11:
          if (in.readIndex() != 1) {
            in.readNull();
            this.filesize = null;
          } else {
            this.filesize = in.readString(this.filesize instanceof Utf8 ? (Utf8)this.filesize : null);
          }
          break;

        case 12:
          if (in.readIndex() != 1) {
            in.readNull();
            this.series = null;
          } else {
            this.series = in.readString(this.series instanceof Utf8 ? (Utf8)this.series : null);
          }
          break;

        case 13:
          if (in.readIndex() != 0) {
            in.readNull();
            this.periodical = null;
          } else {
            this.periodical = in.readBoolean();
          }
          break;

        case 14:
          if (in.readIndex() != 1) {
            in.readNull();
            this.description = null;
          } else {
            this.description = in.readString(this.description instanceof Utf8 ? (Utf8)this.description : null);
          }
          break;

        case 15:
          if (in.readIndex() != 1) {
            in.readNull();
            this.cover = null;
          } else {
            this.cover = in.readString(this.cover instanceof Utf8 ? (Utf8)this.cover : null);
          }
          break;

        default:
          throw new java.io.IOException("Corrupt ResolvingDecoder.");
        }
      }
    }
  }
}










